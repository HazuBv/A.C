--!strict
-- Script pour le Monde 1 d'Arise Crossover.
-- Ce script contient des fonctionnalit√©s d'automatisation pour le farm, le donjon, le ch√¢teau et la t√©l√©portation.

local getgenv: () -> ({[string]: any}) = getfenv().getgenv

getgenv().ScriptVersion = "v3"

-- Charge le Cheese Core.
do
  local Core = loadstring(game:HttpGet("https://github.com/aw4e/Cheese/raw/dev/Core.lua"))
  if not Core then return warn("√âchec du chargement du Cheese Core") end
  Core()
end

-- Types (pour le typage strict, pas pour la logique d'ex√©cution directe)
type Element = {
	CurrentValue: any,
	CurrentOption: {string},
	Set: (self: Element, any) -> ()
}

type Flags = {[string]: Element}

type Tab = {
	CreateSection: (self: Tab, Name: string) -> Element,
	CreateDivider: (self: Tab) -> Element,
	CreateToggle: (self: Tab, any, string?) -> Element,
	CreateSlider: (self: Tab, any, string?) -> Element,
	CreateDropdown: (self: Tab, any, string?) -> Element,
	CreateButton: (self: Tab, any) -> Element,
	CreateLabel: (self: Tab, any, any?) -> Element,
	CreateParagraph: (self: Tab, any) -> Element,
    CreateInput: (self: Tab, any, string?) -> Element,
}


-- Variables et initialisation robuste
local Notify: (Title: string, Content: string, Image: string?) -> () = getgenv().Notify or function(title, content, image) print("Notification: " .. title .. " - " .. content) end
local CreateFeature: (Tab: Tab, FeatureName: string) -> () = getgenv().CreateFeature or function(tab, name) warn("CreateFeature non impl√©ment√© par le Core") end
local HandleConnection: (Connection: RBXScriptConnection, Name: string) -> () = getgenv().HandleConnection or function(conn, name) conn:Disconnect() end

local queue_on_teleport: (Code: string) -> () = getfenv().queue_on_teleport or function(code) warn("queue_on_teleport non disponible dans cet environnement") end

local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("HumanoidRootPart")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")

-- Initialisation robuste des services et dossiers avec des d√©lais d'attente
local Remotes = ReplicatedStorage:WaitForChild("BridgeNet2", 10) and ReplicatedStorage.BridgeNet2:WaitForChild("dataRemoteEvent", 10)
if not Remotes then warn("BridgeNet2 ou dataRemoteEvent non trouv√©s!") end

local Pets = workspace:WaitForChild("__Main", 10) and workspace.__Main:WaitForChild("__Pets", 10)
local Mobs = workspace:WaitForChild("__Main", 10) and workspace.__Main:WaitForChild("__Enemies", 10)
local Worlds = workspace:WaitForChild("__Main", 10) and workspace.__Main:WaitForChild("__World", 10)
local Spawns = workspace:WaitForChild("__Extra", 10) and workspace.__Extra:WaitForChild("__Spawns", 10)
local Dungeon = workspace:WaitForChild("__Main", 10) and workspace.__Main:WaitForChild("__Dungeon", 10)

-- GamePass (Les attributs des GamePass sont g√©n√©ralement d√©finis c√¥t√© serveur, ces lignes peuvent ne pas avoir d'effet)
Player.Settings:SetAttribute("AutoAttack", true)
Player.leaderstats.Passes:SetAttribute("AutoAttack", true)
Player.leaderstats.Passes:SetAttribute("AutoClicker", true)

Player.Settings:SetAttribute("UnitySends", false)

-- Met √† jour les r√©f√©rences du personnage et de l'HumanoidRootPart lors du rechargement du personnage
Player.CharacterAdded:Connect(function(NewCharacater)
	Character = NewCharacater
    Humanoid = Character:WaitForChild("HumanoidRootPart")
end)

-- G√®re les t√©l√©portations pour recharger le script si n√©cessaire
Player.OnTeleport:Connect(function()
	if game.GameId == 7074860883 then
		queue_on_teleport([[
            task.spawn(function()
                task.wait(5)
                loadstring(game:HttpGet("https://github.com/aw4e/Cheese/raw/dev/Loader.lua"))()
            end)
        ]])
	end
end)

-- D√©finitions des mondes, √Æles, mobs, etc.
local AllMobWorlds = {
	["SoloWorld"] = {"Soondoo", "Gonshee", "Daek", "Longin", "Anders", "Largalgan"},
	["NarutoWorld"] = {"Snake Man", "Blossom", "Black Crow"},
	["OPWorld"] = {"Shark Man", "Eminel", "Light Admiral"},
	["BleachWorld"] = {"Luryu", "Fyakuya", "Genji"},
	["BCWorld"] = {"Sortudo", "Michille", "Wind"},
	["ChainsawWorld"] = {"Heaven", "Zere", "Ika"},
	["JojoWorld"] = {"Diablo", "Gosuke", "Golyne"},
	["DBWorld"] = {"Turtle", "Green", "Sky"},
	["OPMWorld"] = {"Rider", "Cyborg", "Hurricane"}
}

local Islands = {}
if Spawns then -- S'assure que Spawns existe avant d'it√©rer
    for _, Island in pairs(Spawns:GetChildren()) do
        Islands[Island.Name] = Island.CFrame
    end
else
    warn("Dossier __Spawns non trouv√© pour la population des √Æles.")
end


local IslandKeys = {}
for key, _ in pairs(Islands) do
	table.insert(IslandKeys, key)
end
table.sort(IslandKeys) -- Trie les cl√©s pour un affichage coh√©rent

local CodeWorlds = {
	SL = "SoloWorld",
	NR = "NarutoWorld",
	OP = "OPWorld",
	BL = "BleachWorld",
	BC = "BCWorld",
	CH = "ChainsawWorld",
	JB = "JojoWorld",
	DB = "DBWorld",
	OPM = "OPMWorld",
}

local VillageNames = {
	["Grass Village"] = "NarutoWorld",
	["Brum Island"] = "OPWorld",
	["Leveling City"] = "SoloWorld",
	["Faceheal Town"] = "BleachWorld",
	["Lucky Kingdom"] = "BCWorld",
	["Nipon City"] = "ChainsawWorld",
	["Mori Town"] = "JojoWorld",
	["Dragon City"] = "DBWorld",
	["XZ City"] = "OPMWorld"
}

local VillageSpawns = {}
for Key, Value in pairs(VillageNames) do
	VillageSpawns[string.lower(Key)] = Value
end

local RankMaps = {
	"E", "D", "C", "B", "A", "S", "SS", "G", "N", "N+"
}

local RankValues = {}
for _, Value in ipairs(RankMaps) do
	table.insert(RankValues, "Rank " .. Value)
end

local MobTypes = { "Normal", "Big" }

local Runes = {
	["Rune Leveling City"] = "DgSoloRune",
	["Rune Grass Village"] = "DgNarutoRune",
	["Rune Brum Island"] = "DgOPRune",
	["Rune Dragon City"] = "DgDBRune",
	["Rune Faceheal"] = "DgBleachRune",
	["Rune Lucky Kingdom"] = "DgBCRune",
	["Rune Nipon City"] = "DgChainsawRune",
	["Rune Mori Town"] = "DgJojoRune",
	["Rune Rank Up"] = "DgRankUpRune"
}

local DgRunes = {}
for Key, _ in pairs(Runes) do
	table.insert(DgRunes, Key)
end

-- Anti-triche (tente de d√©truire les CharacterScripts, peut causer des probl√®mes si le jeu les utilise)
task.spawn(function()
  while true and task.wait(.1) do
    if Player and Character then
      local CharacterScripts = Character:FindFirstChild("CharacterScripts")
      if CharacterScripts then
        for _, Child in ipairs(CharacterScripts:GetChildren()) do
          Child:Destroy()
        end
      end
    end
  end
})

-- Caract√©ristiques de l'interface utilisateur
local Flags: Flags = getgenv().Flags
local Window = getgenv().Window

local Tab: Tab = Window:CreateTab({
	Name = "Automation",
	Icon = "code",
	ImageSource = "Lucide",
	ShowTitle = false
})

Tab:CreateSection("Mobs")

Tab:CreateDropdown({
  Name = "S√©lectionner le Monde",
  Description = "S√©lectionnez le monde que vous voulez farmer",
  Options = IslandKeys,
  CurrentOption = {},
  MultipleOptions = false,
  SpecialType = nil,
  Callback = function(Value)
    local MobList = AllMobWorlds[Value]
    if MobList and #MobList > 0 then
        if Flags.SelectMob then
            Flags.SelectMob:Set({
                Options = MobList,
                CurrentOption = {}
            })
        else
            warn("Flags.SelectMob non initialis√©!")
        end
    else
        Notify("S√©lection des Mobs üó∫Ô∏è", "Aucun mob trouv√© pour le monde s√©lectionn√©: " .. tostring(Value) .. " üö´", "_error")
    end
  end
}, "SelectWorld")

Tab:CreateDropdown({
  Name = "S√©lectionner le Mob",
  Description = "S√©lectionnez le mob que vous voulez farmer",
  Options = {},
  CurrentOption = {},
  MultipleOptions = true,
  SpecialType = nil,
  Callback = function()end
}, "SelectMob")

Tab:CreateDropdown({
  Name = "S√©lectionner le Type",
  Description = "S√©lectionnez le type de mob que vous voulez farmer",
  Options = MobTypes,
  CurrentOption = {},
  MultipleOptions = true,
  SpecialType = nil,
  Callback = function()end
}, "SelectType")

Tab:CreateSlider({
  Name = "D√©lai de Farm",
  Description = "D√©finissez le d√©lai entre les actions de farm",
  Range = {0.1, 5},
  Increment = 0.1,
  CurrentValue = 0.5,
  Callback = function()end
}, "DelayFarm")

-- Fonction pour la t√©l√©portation instantan√©e
local function InstantTeleport(targetCFrame)
    if Character then
        Character:PivotTo(targetCFrame)
    else
        warn("Personnage non trouv√© pour la t√©l√©portation instantan√©e!")
    end
end

-- Fonction pour la t√©l√©portation avec tween
local function TweenToPosition(character, targetPosition)
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        warn("Personnage ou HumanoidRootPart invalide pour TweenToPosition!")
        return
    end
    local TweenService = game:GetService("TweenService")
    local TweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local Goal = {CFrame = CFrame.new(targetPosition)}
    local Tween = TweenService:Create(character.HumanoidRootPart, TweenInfo, Goal)
    Tween:Play()
    Tween.Completed:Wait()
end

-- Fonction pour l'attaque
local function ShadowAttack(Target)
    if not Remotes then warn("Remotes non disponibles pour ShadowAttack!") return end
    if not Target or not Target.Name then warn("Cible invalide pour ShadowAttack!") return end

    local Args = {
        [1] = {
            [1] = {
                ["Event"] = "PunchAttack",
                ["Enemy"] = Target.Name
            },
            [2] = "\4"
        }
    }
    Remotes:FireServer(unpack(Args))
end


local function IsInDungeon()
  return game.PlaceId ~= 87039211657390
end

local function HasAvailablePrompt(Mob)
  local RootPart = Mob:FindFirstChild("HumanoidRootPart")
  if not RootPart then return false end

  for _, Prompt in pairs(RootPart:GetChildren()) do
    if Prompt:IsA("ProximityPrompt") and Prompt.Enabled then
      return true
    end
  end
  return false
end

local function GetMobNameFromModel(Model)
	local Code, Id = Model:match("^(%a+)(%d+)$")
    local WorldName = CodeWorlds[Code]
    local Mob = WorldName and AllMobWorlds[WorldName]
	return Mob and Id and Mob[tonumber(Id)] or nil
end

local function GetMobTypeFromId(Id)
	return #Id > 3 and Id:match("B%d$") and "Big" or "Normal"
end

local function GetNearestMob(Options)
  Options = Options or {}
  local MaxDistance = Options.MaxDistance
  local UseFilter = Options.UseFilter

  local NearestMob, ShortestDistance = nil, math.huge
  local PlayerPos = Humanoid and Humanoid.Position -- S'assure que Humanoid existe

  if not PlayerPos then return nil end -- Quitte si la position du joueur n'est pas disponible

  local ServerFolder = Mobs and Mobs:FindFirstChild("Server")
  local ClientFolder = Mobs and Mobs:FindFirstChild("Client")

  if not ServerFolder then warn("Dossier Mobs/Server non trouv√©!") return nil end

  local SelectedMobs = Flags.SelectMob and Flags.SelectMob.CurrentOption or {}
  local SelectedTypes = Flags.SelectType and Flags.SelectType.CurrentOption or {}

  for _, SubFolder in pairs(ServerFolder:GetChildren()) do
    if not SubFolder:IsA("Folder") and not SubFolder:GetAttribute("Dead") then
      if UseFilter then
        local Model = SubFolder:GetAttribute("Model")
        local Id = SubFolder:GetAttribute("Id")

        local MobType = GetMobTypeFromId(tostring(Id))
        local MobName = GetMobNameFromModel(tostring(Model))

        if not table.find(SelectedMobs, MobName) or not table.find(SelectedTypes, MobType) then
          continue
        end
      end

      local MobPos = SubFolder:GetPivot().Position
      local Distance = (PlayerPos - MobPos).Magnitude

      if MaxDistance and Distance > MaxDistance then
        continue
      end

      if Distance < ShortestDistance then
        ShortestDistance = Distance
        NearestMob = SubFolder
      end
    elseif SubFolder:IsA("Folder") and #SubFolder:GetChildren() > 0 then
      for _, Mob in pairs(SubFolder:GetChildren()) do
        if Mob:IsA("Instance") and not Mob:GetAttribute("Dead") then
          if UseFilter then
            local Model = Mob:GetAttribute("Model")
            local Id = Mob:GetAttribute("Id")

            local MobType = GetMobTypeFromId(tostring(Id))
            local MobName = GetMobNameFromModel(tostring(Model))

            if not table.find(SelectedMobs, MobName) or not table.find(SelectedTypes, MobType) then
              continue
            end
          end

          local MobPos = Mob:GetPivot().Position
          local Distance = (PlayerPos - MobPos).Magnitude

          if MaxDistance and Distance > MaxDistance then
            continue
          end

          if Distance < ShortestDistance then
            ShortestDistance = Distance
            NearestMob = Mob
          end
        end
      end
    end
  end

  return NearestMob
end

local function GetAnyMob()
	local ServerFolder = Mobs and Mobs:FindFirstChild("Server")
    if not ServerFolder then warn("Dossier Mobs/Server non trouv√© pour GetAnyMob!") return nil end

	for _, SubFolder in ipairs(ServerFolder:GetChildren()) do
		if not SubFolder:IsA("Folder") and not SubFolder:GetAttribute("Dead") then
            return SubFolder
        end

		if SubFolder:IsA("Folder") and #SubFolder:GetChildren() > 0 then
			for _, Mob in ipairs(SubFolder:GetChildren()) do
				if Mob:IsA("Instance") and not Mob:GetAttribute("Dead") then
					return Mob
				end
			end
		end
	end
	return nil
end

Tab:CreateToggle({
  Name = "Auto Farm Mobs S√©lectionn√©s ‚öîÔ∏è",
  Description = "Farme automatiquement les mobs en fonction de votre s√©lection",
  Callback = function()
    while Flags.AutoFarmSelectedMobs.CurrentValue and task.wait(.1) do
      local Target
			repeat
				Target = GetNearestMob({
          UseFilter = true,
        })
				task.wait(.1)
			until Target and Target:IsA("Instance") and not Target:GetAttribute("Dead")

      if Target then
        local TargetPos = Target:GetPivot().Position
        local PlayerPos = Character:GetPivot().Position
        local Distance = (PlayerPos - TargetPos).Magnitude

        if Distance > 10 then
          -- Utilise la m√©thode de t√©l√©portation s√©lectionn√©e
          local farmTeleportMethod = Flags.FarmTeleportMethod and Flags.FarmTeleportMethod.CurrentOption
          if farmTeleportMethod == "Instant" then
            InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
          elseif farmTeleportMethod == "Bypass (tween)" then
            TweenToPosition(Character, TargetPos + Vector3.new(0, 0, 6))
          else
            -- Par d√©faut, t√©l√©portation instantan√©e si la m√©thode n'est pas s√©lectionn√©e ou invalide
            InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
          end
          task.wait(tonumber(Flags.DelayFarm.CurrentValue or 0.5)) -- D√©lai par d√©faut si non d√©fini
          ShadowAttack(Target)
        end
      end
    end
  end
}, "AutoFarmSelectedMobs")

Tab:CreateToggle({
  Name = "Auto Farm N'importe Quel Mob üéØ",
  Description = "Farme automatiquement n'importe quel mob disponible",
  Callback = function()
    while Flags.AutoFarmAnyMobs.CurrentValue and task.wait(.1) do
      local Target
      repeat
        Target = GetAnyMob()
        task.wait(.1)
      until Target and Target:IsA("Instance") and not Target:GetAttribute("Dead")

      if Target then
        local TargetPos = Target:GetPivot().Position + Vector3.new(0, 0, 6)
        local PlayerPos = Character:GetPivot().Position
        local Distance = (PlayerPos - TargetPos).Magnitude

        if Distance > 10 then
          -- Utilise la m√©thode de t√©l√©portation s√©lectionn√©e
          local farmTeleportMethod = Flags.FarmTeleportMethod and Flags.FarmTeleportMethod.CurrentOption
          if farmTeleportMethod == "Instant" then
            InstantTeleport(CFrame.new(TargetPos))
          elseif farmTeleportMethod == "Bypass (tween)" then
            TweenToPosition(Character, TargetPos)
          else
            -- Par d√©faut, t√©l√©portation instantan√©e si la m√©thode n'est pas s√©lectionn√©e ou invalide
            InstantTeleport(CFrame.new(TargetPos))
          end
          task.wait(tonumber(Flags.DelayFarm.CurrentValue or 0.5)) -- D√©lai par d√©faut si non d√©fini
          ShadowAttack(Target)
        end
      end
    end
  end
}, "AutoFarmAnyMobs")

Tab:CreateDivider()

local function AttackMob(Mob)
    if not Remotes then warn("Remotes non disponibles pour AttackMob!") return end
    if not Mob or not Mob.Name then warn("Mob invalide pour AttackMob!") return end
    local Args = {
        [1] = {
            [1] = {
                ["Event"] = "PunchAttack",
                ["Enemy"] = Mob.Name
            },
            [2] = "\4"
        }
    }
    Remotes:FireServer(unpack(Args))
end

Tab:CreateToggle({
  Name = "Auto Attaque Mob üëä",
  Description = "Attaque automatiquement le mob le plus proche √† port√©e",
  Callback = function()
    while Flags.AutoAttackMob.CurrentValue and task.wait(.01) do
      local Target
      repeat
        Target = GetNearestMob({
          MaxDistance = 10,
          UseFilter = false
        })
        task.wait(.1)
      until Target and Target:IsA("Instance") and not Target:GetAttribute("Dead")

      if Target then
        AttackMob(Target)
      end
    end
  end
}, "AutoAttackMob")

Tab:CreateToggle({
  Name = "Auto Arise Mob üëª",
  Description = "Capture automatiquement les mobs disponibles",
  Callback = function()
    while Flags.AutoAriseMob.CurrentValue and task.wait() do
      local ClientFolder = Mobs and Mobs:FindFirstChild("Client")
      if not ClientFolder then warn("Dossier Mobs/Client non trouv√© pour Auto Arise Mob!") continue end

      for _, Mob in ipairs(ClientFolder:GetChildren()) do
        local Prompt = Mob:FindFirstChild("HumanoidRootPart") and Mob.HumanoidRootPart:FindFirstChild("ArisePrompt")
        if Prompt then
            if not Remotes then warn("Remotes non disponibles pour Auto Arise Mob!") break end
            local Args = {
                [1] = {
                    [1] = {
                        ["Event"] = "EnemyCapture",
                        ["Enemy"] = Mob.Name
                    },
                    [2] = "\4"
                }
            }
            Remotes:FireServer(unpack(Args))
        end
      end
    end
  end
}, "AutoAriseMob")

Tab:CreateToggle({
  Name = "Auto D√©truire Mob üí•",
  Description = "D√©truit automatiquement les mobs disponibles",
  Callback = function()
    while Flags.AutoDestroyMob.CurrentValue and task.wait() do
      local ClientFolder = Mobs and Mobs:FindFirstChild("Client")
      if not ClientFolder then warn("Dossier Mobs/Client non trouv√© pour Auto D√©truire Mob!") continue end

      for _, Mob in ipairs(ClientFolder:GetChildren()) do
        local Prompt = Mob:FindFirstChild("HumanoidRootPart") and Mob.HumanoidRootPart:FindFirstChild("DestroyPrompt")
        if Prompt then
            if not Remotes then warn("Remotes non disponibles pour Auto D√©truire Mob!") break end
            local Args = {
                [1] = {
                    [1] = {
                        ["Event"] = "EnemyDestroy",
                        ["Enemy"] = Mob.Name
                    },
                    [2] = "\4"
                }
            }
            Remotes:FireServer(unpack(Args))
        end
      end
    end
  end
}, "AutoDestroyMob")

Tab:CreateSection("Shop")

Tab:CreateDropdown({
  Name = "S√©lectionner le Rang d'Ombre üí∞",
  Description = "S√©lectionnez le rang d'ombres que vous voulez vendre",
  Options = RankValues,
  CurrentOption = {},
  MultipleOptions = true,
  SpecialType = nil,
  Callback = function()end
}, "SelectShadowRank")

Tab:CreateToggle({
  Name = "Auto Vendre Rang d'Ombre üí∏",
  Description = "Vend automatiquement les ombres des rangs s√©lectionn√©s",
  Callback = function()
    while Flags.AutoSellShadowRank.CurrentValue and task.wait(.1) do
      local PetsFolder = Player.leaderstats.Inventory:FindFirstChild("Pets")
      if not PetsFolder then Notify("Boutique ‚ö†Ô∏è", "Inventaire des familiers non trouv√©!", "_error") continue end

      local RankNumbers = {}

      local selectedRanks = Flags.SelectShadowRank and Flags.SelectShadowRank.CurrentOption
      if type(selectedRanks) ~= "table" then
          warn("Flags.SelectShadowRank.CurrentOption n'est pas une table!")
          continue
      end

      for _, RankString in ipairs(selectedRanks) do
        local RankLetter = string.sub(RankString, 6)
        
        for Num, Letter in ipairs(RankMaps) do
          if Letter == RankLetter then
            table.insert(RankNumbers, Num)
            break
          end
        end
      end

      if #RankNumbers > 0 then
        for _, Pet in ipairs(PetsFolder:GetChildren()) do
          local RankValue = Pet:GetAttribute("Rank")
          
          if typeof(RankValue) == "number" then
            for _, Rank in ipairs(RankNumbers) do
              if RankValue == Rank then
                if not Remotes then Notify("Boutique ‚ö†Ô∏è", "Remotes non disponibles pour la vente de familiers!", "_error") break end
                local Args = {
                  [1] = {
                    [1] = {
                      ["Event"] = "SellPet",
                      ["Pets"] = {Pet.Name}
                    },
                    [2] = "\5"
                  }
                }
                Remotes:FireServer(unpack(Args))
                task.wait(.3)
                break
              end
            end
          end
        end
      end
    end
  end
}, "AutoSellShadowRank")

Tab:CreateSection("Dungeon")

Tab:CreateButton({
  Name = "Donjon de Rang Sup√©rieur ‚¨ÜÔ∏è",
  Description = "Aller au donjon de rang sup√©rieur",
  Callback = function()
    if not Remotes then Notify("Donjon ‚ö†Ô∏è", "Remotes non disponibles pour le Donjon de Rang Sup√©rieur!", "_error") return end
    local Args = {
      [1] = {
        [1] = {
          ["Event"] = "DungeonAction",
          ["Action"] = "TestEnter"
        },
        [2] = "\n"
      }
    }
    Remotes:FireServer(unpack(Args))
    Notify("Donjon üöÄ", "Tentative d'entr√©e dans le Donjon de Rang Sup√©rieur!", "swords", "Lucide")
  end
})

Tab:CreateDivider()

local function TeleportToSpawn(SpawnName)
    if not Remotes then warn("Remotes non disponibles pour TeleportToSpawn!") return end
	local Args = {
		[1] = {
			[1] = {
				["Event"] = "ChangeSpawn",
				["Spawn"] = SpawnName
			},
			[2] = "\n"
		}
	}
	Remotes:FireServer(unpack(Args))
	task.wait(.5)
	if Character then
		Character:BreakJoints()
	end
end

local function CreateAndStartDungeon(dungeonId)
    if not Remotes then warn("Remotes non disponibles pour CreateAndStartDungeon!") return end

	local Args = {
		[1] = {
			[1] = {
				["Event"] = "DungeonAction",
				["Action"] = "Create"
			},
			[2] = "\n"
		}
	}
	Remotes:FireServer(unpack(Args))
	task.wait(.2)
	
    local dungeonRunes = Flags.DungeonRune and Flags.DungeonRune.CurrentOption
	if type(dungeonRunes) == "table" and #dungeonRunes > 0 then
		for key, Rune in ipairs(dungeonRunes) do
			local Args = {
				[1] = {
					[1] = {
						["Dungeon"] = dungeonId,
						["Action"] = "AddItems",
						["Slot"] = key,
						["Event"] = "DungeonAction",
						["Item"] = Runes[Rune]
					},
					[2] = "\n"
				}
			}
			Remotes:FireServer(unpack(Args))
			task.wait(.2)
		end
	end
	
	local Args = {
		[1] = {
			[1] = {
				["Dungeon"] = dungeonId,
				["Event"] = "DungeonAction",
				["Action"] = "Start"
			},
			[2] = "\n"
		}
	}
	Remotes:FireServer(unpack(Args))
end

Tab:CreateDropdown({
  Name = "S√©lectionner le Donjon üèûÔ∏è",
  Description = "S√©lectionnez le donjon que vous voulez faire",
  Options = IslandKeys,
  CurrentOption = {},
  MultipleOptions = true,
  SpecialType = nil,
  Callback = function()end
}, "SelectDungeon")

Tab:CreateDropdown({
  Name = "S√©lectionner la Rune de Donjon ‚ú®",
  Description = "S√©lectionnez la rune que vous voulez utiliser (Max 5)",
  Options = DgRunes,
  CurrentOption = {},
  MultipleOptions = true,
  SpecialType = nil,
  Callback = function(Value)
    if type(Value) == "table" and #Value > 5 then
			table.remove(Value, #Value)
			Notify("Donjon üö´", "Vous ne pouvez s√©lectionner que 5 Runes!", "swords", "Lucide")
            if Flags.DungeonRune then
                Flags.DungeonRune:Set({
                    CurrentOption = Value
                })
            else
                warn("Flags.DungeonRune non initialis√©!")
            end
		end
  end
}, "DungeonRune")

function Rejoin(Id)
    Notify("Rejoindre üîÑ", "Rejoindre la partie...", "sailboat", "Lucide")
	TeleportService:Teleport(Id)
end

Tab:CreateToggle({
  Name = "Auto D√©tecter Donjon üîî",
  Description = "D√©tecte et se t√©l√©porte automatiquement aux nouveaux donjons",
  Callback = function()
    while Flags.AutoDetectDungeon.CurrentValue and task.wait(.1) do
      local WarnGui = Player.PlayerGui:FindFirstChild("Warn")
			if not WarnGui then continue end

      for _, DungeonFrame in ipairs(WarnGui:GetChildren()) do -- Renomm√© 'Dungeon' en 'DungeonFrame' pour √©viter les conflits
        if not DungeonFrame:IsA("Frame") then continue end

        for _, Child in ipairs(DungeonFrame:GetChildren()) do
          if not Child:IsA("ImageLabel") then continue end

          local WarnMessage = Child:FindFirstChild("WarnMessage")
					if WarnMessage and WarnMessage:IsA("TextLabel") then
            local Text = WarnMessage.Text
						if not string.find(Text, "SPAWNED") then continue end

						local CodeIsland = VillageSpawns[string.lower(Text)]
						local SelectedList = Flags.SelectDungeon and Flags.SelectDungeon.CurrentOption or {}
                        if #SelectedList == 0 then SelectedList = IslandKeys end -- Utilise IslandKeys si rien n'est s√©lectionn√©

						for _, Selected in ipairs(SelectedList) do
							if CodeIsland == Selected then
								Notify("Donjon üöÄ", "T√©l√©portation vers " .. Text .. "!", "swords", "Lucide")
								TeleportToSpawn(CodeIsland)
								break
							end
						end
          end
        end
      end
    end
  end
}, "AutoDetectDungeon")

Tab:CreateDropdown({
  Name = "Mode Donjon ‚öôÔ∏è",
  Description = "S√©lectionnez le mode de donjon (T√©l√©portation ou Bypass)",
  Options = { "Teleport", "Bypass" },
  CurrentOption = "Teleport", -- Valeur par d√©faut
  MultipleOptions = false,
  SpecialType = nil,
  Callback = function()end
}, "DungeonMode")

local function BuyTicket()
    if not Remotes then warn("Remotes non disponibles pour BuyTicket!") return end
    local Args = {
        [1] = {
            [1] = {
                ["Type"] = "Gems",
                ["Event"] = "DungeonAction",
                ["Action"] = "BuyTicket"
            },
            [2] = "\n"
        }
    }
    Remotes:FireServer(unpack(Args))
    Notify("Ticket üéüÔ∏è", "Tentative d'achat d'un ticket de donjon!", "swords", "Lucide")
end

Tab:CreateToggle({
  Name = "Auto Acheter Ticket üíé",
  Description = "Ach√®te automatiquement les tickets de donjon si n√©cessaire",
  Callback = function()
    if not IsInDungeon() then BuyTicket() end -- V√©rification initiale
    while Flags.AutoBuyTicket.CurrentValue and task.wait(.1) do
      local WarnGui = Player.PlayerGui:FindFirstChild("Warn")
			if not WarnGui then continue end

			for _, DungeonFrame in ipairs(WarnGui:GetChildren()) do
				if not DungeonFrame:IsA("Frame") then continue end

				for _, Child in ipairs(DungeonFrame:GetChildren()) do
					if not Child:IsA("ImageLabel") then continue end

					local WarnMessage = Child:FindFirstChild("WarnMessage")
					if WarnMessage and WarnMessage:IsA("TextLabel") then
						if string.find(string.lower(WarnMessage.Text), "completed") then
              BuyTicket()
							break
						end
					end
				end
			end
    end
  end
}, "AutoBuyTicket")

Tab:CreateToggle({
  Name = "Auto Donjon üîÅ",
  Description = "Automatise les runs de donjon en fonction du mode s√©lectionn√©",
  Callback = function()
    local dungeonMode = Flags.DungeonMode and Flags.DungeonMode.CurrentOption
    if dungeonMode == "Bypass" and not IsInDungeon() then
        CreateAndStartDungeon(Player.UserId)
        Notify("Auto Donjon üöÄ", "Bypass de l'entr√©e du donjon!", "swords", "Lucide")
    end

    task.spawn(function()
      while Flags.AutoDungeon.CurrentValue and task.wait(0.1) do
        local UpContainer = Player.PlayerGui.Hud:FindFirstChild("UpContanier")
        if UpContainer then
          local InfoText = UpContainer:FindFirstChild("DungeonInfo") and UpContainer.DungeonInfo.TextLabel.Text
          if InfoText and string.find(InfoText, "Dungeon End") then
            Notify("Fin du Donjon üéâ", "Donjon termin√©!", "swords", "Lucide")
            if dungeonMode == "Teleport" then
              Rejoin(87039211657390)
            else
              CreateAndStartDungeon(Player.UserId)
            end
          end
        end
  
        if dungeonMode == "Teleport" then
            if Dungeon then -- S'assure que Dungeon existe
                for _, Obj in ipairs(Dungeon:GetChildren()) do
                    if Obj:IsA("Part") then
                        task.wait(0.1)
                        if Character then
                            Character:PivotTo(Obj.CFrame * CFrame.new(0, 0, 6))
                        end
                        task.wait(0.3)
                        CreateAndStartDungeon(Player.UserId)
                    end
                end
            else
                warn("Dossier Dungeon non trouv√© pour le mode T√©l√©portation!")
            end
        else
          local WarnGui = Player.PlayerGui:FindFirstChild("Warn")
          if not WarnGui then continue end
  
          for _, DungeonFrame in ipairs(WarnGui:GetChildren()) do
            if not DungeonFrame:IsA("Frame") then continue end
  
            for _, Child in ipairs(DungeonFrame:GetChildren()) do
              if not Child:IsA("ImageLabel") then continue end
  
              local WarnMessage = Child:FindFirstChild("WarnMessage")
              if WarnMessage and WarnMessage:IsA("TextLabel") then
                if string.find(string.lower(WarnMessage.Text), "reset!") then
                  Notify("R√©initialisation du Donjon üîÑ", "R√©initialisation du donjon d√©tect√©e, red√©marrage!", "swords", "Lucide")
                  CreateAndStartDungeon(Player.UserId)
                end
              end
            end
          end
        end
      end
    end)

    task.spawn(function()
      while Flags.AutoDungeon.CurrentValue and task.wait(0.1) do
        local Target
        repeat
          Target = GetAnyMob()
          task.wait(0.1)
        until Target and Target:IsA("Instance") and not Target:GetAttribute("Dead")

        if Target then
          local TargetPos = Target:GetPivot().Position
          local PlayerPos = Character:GetPivot().Position
          local Distance = (PlayerPos - TargetPos).Magnitude

          if Distance > 10 then
            local farmTeleportMethod = Flags.FarmTeleportMethod and Flags.FarmTeleportMethod.CurrentOption
            if farmTeleportMethod == "Instant" then
                InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
            elseif farmTeleportMethod == "Bypass (tween)" then
                TweenToPosition(Character, TargetPos + Vector3.new(0, 0, 6))
            else
                -- Par d√©faut, t√©l√©portation instantan√©e si la m√©thode n'est pas s√©lectionn√©e ou invalide
                InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
            end
            task.wait(tonumber(Flags.DelayFarm.CurrentValue or 0.5))
            ShadowAttack(Target)
          end
        end
      end
    end)
  end
}, "AutoDungeon")

local Tab: Tab = Window:CreateTab({
    Name = "Ch√¢teau",
    Icon = "castle",
    ImageSource = "Lucide",
    ShowTitle = false
})

Tab:CreateSection("Farm")

Tab:CreateToggle({
    Name = "Utiliser Dernier Checkpoint ‚úÖ",
    Description = "Commencer √† partir du dernier checkpoint sauvegard√© dans le ch√¢teau",
    Callback = function()end
}, "UseLastCheckpoint")

Tab:CreateToggle({
    Name = "Auto Ch√¢teau üè∞",
    Description = "Progresse automatiquement dans les √©tages du ch√¢teau",
    Callback = function()
        local LastFloor = nil

        while Flags.AutoCastle.CurrentValue and task.wait(0.1) do
            if not Remotes then Notify("Ch√¢teau ‚ö†Ô∏è", "Remotes non disponibles pour Auto Ch√¢teau!", "_error") break end
            local Args = {
                [1] = {
                    [1] = {
                        ["Check"] = Flags.UseLastCheckpoint and Flags.UseLastCheckpoint.CurrentValue,
                        ["Event"] = "CastleAction",
                        ["Action"] = "Join"
                    },
                    [2] = "\n"
                }
            }
            Remotes:FireServer(unpack(Args))
            Notify("Ch√¢teau ‚û°Ô∏è", "Tentative de rejoindre le ch√¢teau!", "castle", "Lucide")

            local Target = GetAnyMob()
            if Target and Target:IsA("Instance") and not Target:GetAttribute("Dead") then
                if Target then
                    local TargetPos = Target:GetPivot().Position
                    local PlayerPos = Character:GetPivot().Position
                    local Distance = (PlayerPos - TargetPos).Magnitude

                    if Distance > 10 then
                        local farmTeleportMethod = Flags.FarmTeleportMethod and Flags.FarmTeleportMethod.CurrentOption
                        if farmTeleportMethod == "Instant" then
                            InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
                        elseif farmTeleportMethod == "Bypass (tween)" then
                            TweenToPosition(Character, TargetPos + Vector3.new(0, 0, 6))
                        else
                            InstantTeleport(CFrame.new(TargetPos) * CFrame.new(0, 0, 6))
                        end
                        task.wait(tonumber(Flags.DelayFarm.CurrentValue or 0.5))
                        ShadowAttack(Target)
                    end
                end
            else
                local WorldsFolder = workspace:FindFirstChild("__Main") and workspace.__Main:FindFirstChild("__World")
                local UpContainer = Player.PlayerGui.Hud:FindFirstChild("UpContanier")
                local RoomText = UpContainer and UpContainer:FindFirstChild("Room")

                if WorldsFolder and RoomText and RoomText:IsA("TextLabel") then
                    local UpText = RoomText.Text
                    local CurrentFloor = tonumber(UpText:match("Floor: (%d+)/%d+"))

                    if CurrentFloor then
                        if LastFloor ~= CurrentFloor then
                            LastFloor = CurrentFloor
                            local TargetFloor = CurrentFloor + 1

                            local TargetWorld
                            repeat
                                task.wait(.1)
                                TargetWorld = WorldsFolder:FindFirstChild("Room_" .. TargetFloor)
                            until TargetWorld

                            local PlayersSpawns
                            repeat
                                task.wait(.1)
                                PlayersSpawns = TargetWorld:FindFirstChild("PlayersSpawns")
                            until PlayersSpawns

                            task.wait(.1)
                            if Character and PlayersSpawns then
                                Character:PivotTo(PlayersSpawns:GetPivot())
                            end

                            Notify("√âtage ‚¨ÜÔ∏è", "T√©l√©portation vers l'√©tage " .. TargetFloor .. "!", "castle", "Lucide")
                        end
                    end
                end
            end
        end
    end
}, "AutoCastle")

Tab:CreateInput({
    Name = "√âtage √† Quitter üö™",
    Description = "Quitter automatiquement en atteignant +1 cet √©tage. (1-100)",
    PlaceholderText = "25",
    CurrentValue = "25", -- Valeur par d√©faut
    Numeric = true,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Value)
        local Number = tonumber(Value)
        if not Number or Number < 1 or Number > 100 then
            Notify("√âtage Invalide ‚ùå", "Veuillez entrer un nombre entre 1 et 100", "_error")
            if Flags.FloorToLeave then
                Flags.FloorToLeave:Set({
                    CurrentValue = 25
                })
            else
                warn("Flags.FloorToLeave non initialis√©!")
            end
        end
    end
}, "FloorToLeave")

Tab:CreateToggle({
    Name = "Auto Quitter √âtage üëã",
    Description = "Quitter automatiquement le ch√¢teau lorsque l'√©tage cible est atteint",
    Callback = function()
        while Flags.AutoLeaveFloor.CurrentValue and task.wait(0.1) do
            local UpContainer = Player.PlayerGui.Hud:FindFirstChild("UpContanier")
            if not (UpContainer and UpContainer:FindFirstChild("Room") and UpContainer.Room:IsA("TextLabel")) then
                continue
            end

            local UpText = UpContainer.Room.Text
            local CurrentFloor = tonumber(UpText:match("Floor: (%d+)/%d+"))

            local floorToLeave = Flags.FloorToLeave and Flags.FloorToLeave.CurrentValue
            if CurrentFloor and floorToLeave and CurrentFloor > tonumber(floorToLeave) then
                Notify("Quitter le Ch√¢teau üèÉ", "√âtage cible atteint, d√©part!", "castle", "Lucide")
                Rejoin(87039211657390)
            end
        end
    end
}, "AutoLeaveFloor")

local Tab: Tab = Window:CreateTab({
    Name = "T√©l√©portation",
    Icon = "sailboat",
    ImageSource = "Lucide",
    ShowTitle = false
})

Tab:CreateSection("Spawn")

Tab:CreateToggle({
    Name = "Sauvegarder Spawn üìç",
    Description = "Sauvegarder votre position de spawn actuelle",
    Callback = function()end
}, "SaveSpawn")

local function TeleportToIsland(IslandName)
    if IslandName and Islands[IslandName] then
        if Flags.SaveSpawn and Flags.SaveSpawn.CurrentValue then
            if not Remotes then warn("Remotes non disponibles pour TeleportToIsland (SaveSpawn)! ") return end
            local Args = {
                [1] = {
                    [1] = {
                        ["Event"] = "ChangeSpawn",
                        ["Spawn"] = IslandName
                    },
                    [2] = "\n"
                }
            }
            Remotes:FireServer(unpack(Args))
            task.wait(.5)
        end
        task.wait(.1)
        if Character then
            Character:PivotTo(Islands[IslandName])
        else
            Notify("T√©l√©portation ‚ö†Ô∏è", "Personnage non trouv√© pour la t√©l√©portation!", "_error")
        end
    else
        Notify("T√©l√©portation üö´", "√éle '" .. tostring(IslandName) .. "' non trouv√©e ou invalide!", "_error")
    end
end

Tab:CreateDropdown({
    Name = "S√©lectionner Spawn üèùÔ∏è",
    Description = "S√©lectionnez le spawn vers lequel vous voulez vous t√©l√©porter",
    Options = IslandKeys,
    CurrentOption = {},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Value)
        if Value and typeof(Value) == "string" and Value ~= "" then
            Notify("T√©l√©portation ‚úàÔ∏è", "T√©l√©portation vers " .. Value .. "!", "sailboat", "Lucide")
            TeleportToIsland(Value)
        else
            Notify("T√©l√©portation üö´", "Nom d'√Æle ou type invalide", "_error")
        end
    end
}, "SelectSpawn")

Tab:CreateButton({
    Name = "√éle Dedu üó∫Ô∏è",
    Description = "T√©l√©portation vers l'√éle Dedu",
    Callback = function()
        Notify("T√©l√©portation ‚úàÔ∏è", "T√©l√©portation vers l'√éle Dedu!", "sailboat", "Lucide")
        task.wait(.1)
        if Character then
            Character:PivotTo(CFrame.new(3856.48486, 60.1204987, 3077.04736, 0.3869977, -1.41971441e-07, 0.922080696, -2.65326292e-07, 1, 2.65326122e-07, -0.922080696, -3.47332843e-07, 0.3869977))
        else
            Notify("T√©l√©portation ‚ö†Ô∏è", "Personnage non trouv√© pour la t√©l√©portation vers l'√éle Dedu!", "_error")
        end
    end,
})

Tab:CreateButton({
    Name = "√éle Hiver ‚ùÑÔ∏è",
    Description = "T√©l√©portation vers le Raid Hivernal",
    Callback = function()
        Notify("T√©l√©portation ‚úàÔ∏è", "T√©l√©portation vers l'√éle Hiver!", "sailboat", "Lucide")
        task.wait(.1)
        if Character then
            Character:PivotTo(CFrame.new(4782.6416, 29.7264385, -2043.24084, -0.953545272, -1.8529015e-09, 0.301249772, -2.27541319e-11, 1, 6.07869133e-09, -0.301249772, 5.78945292e-09, -0.953545272))
        else
            Notify("T√©l√©portation ‚ö†Ô∏è", "Personnage non trouv√© pour la t√©l√©portation vers l'√éle Hiver!", "_error")
        end
    end
})

local Tab: Tab = Window:CreateTab({
    Name = "QoL",
    Icon = "leaf",
    ImageSource = "Lucide",
    ShowTitle = false
})

Tab:CreateSection("QoL")

-- Nouvelle option pour la m√©thode de t√©l√©portation de farm
Tab:CreateDropdown({
    Name = "M√©thode de T√©l√©portation de Farm ‚ö°",
    Description = "S√©lectionnez la m√©thode de t√©l√©portation pour le farm",
    Options = {"Instant", "Bypass (tween)"},
    CurrentOption = "Instant", -- Valeur par d√©faut
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function()end
}, "FarmTeleportMethod")
